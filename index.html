<html>
<head>
<title>Likely.js Template Library</title>
<link href='http://fonts.googleapis.com/css?family=Roboto:400,100,100italic,300' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Ubuntu+Mono' rel='stylesheet' type='text/css'>
<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="css/bootstrap.min.css">
<style>

body {
  padding:20px 20px 80px 20px;
  font-family:sans-serif;
  font-size:16px;
  color:#333;
  padding-bottom:300px;
}

h1, h2, h3 {
  font-family: 'Roboto', sans-serif;
  font-weight:400;
}

button {
  padding:10px;
}

textarea {
  font-size:16px;
  font-family:'Ubuntu Mono', monospace, "Courier New", Courier;
  color:#000;
}

#resulth * {
  -moz-animation-duration: 3s;
  -webkit-animation-duration: 3s;
  -moz-animation-name: slidein;
  -webkit-animation-name: slidein;
}

@-moz-keyframes slidein {
  from {
    background:#47a447;
  }

  to {
    background:#fff;
  }
}

@-webkit-keyframes slidein {
  from {
    background:#47a447;
  }

  to {
    background:#fff;
  }
}

</style>
</head>
<body>

<div class="container">
  <div class="header">

  <div class="jumbotron">
    <h1>Likely.js Template Library</h1>
    <p class="lead">Likely.js is a templating language for HTML that offers 
      automatic DOM diff, and bidirectional data binding.</p>
    <p>
      <a class="btn btn-lg btn-success" href="https://github.com/batiste/likely.js" role="button">On github <span class="glyphicon glyphicon-download"></span></a>
      <a href="tests/testsuite.html" class="btn btn-lg btn-success">Test suite <span class="glyphicon glyphicon-th-list"></span></a>
    </p>
  </div>
</div>

<h2>Feature highlights</h2>

<ol>
  <li>A simple template and expression language for generating HTML.</li>
  <li>Bidirectional data binding to <strong>any</strong> JavaScript object.</li>
  <li>Likely render the template result in an abstract tree. This enable the template to produce DOM manipulation diff that updates the DOM with minimal impact.</li>
  <li>By design it's hard to insert XSS vulnerabilties even when using untrusted data.</li>
  <li>This is a standalone library that doesn't have any dependencies.</li>
  <li>This library is still pretty much an experiment. I would not recommend it in production yet.</li>
</ol>

<div class="row">
<div class="col-md-6">

<h2>Template Syntax Example</h2>

<textarea id="template" spellcheck="false" class="form-control" rows="10">
p
  "Filter"
  input value={{ searchTerm }} class="form-control"
hr
for key, value in list
  if searchTerm in value
    p
      {{ key }}
      input value={{ value }} class="form-control"</textarea>

</div>
<div class="col-md-6">

<h2>Data used to render the Template</h2>

<textarea id="data" class="form-control" rows="10" spellcheck="false">
{
  "list":{
    "Email":"test@example.com",
    "Firstname":"Charles",
    "Lastname":"Darwin"
  },
  "searchTerm":""
}
</textarea><br>

</div>
</div>

<div class="row">
<div class="col-md-6">

<div id='errors' class="alert alert-danger" style="display:none"></div>

<h2>Result</h2>
<div id="resulth">
</div>

</div>
<div class="col-md-6">


<h2>Html Output</h2>
<p>This output is here for illustration purpose.
<pre id="result">
</pre>

</div>
</div>

<h2>Other examples</h2>

<ol>
<li><a href="crud.html">A basic CRUD application demo.</a></li>
<li><a href="forms.html">Bidirectional data binding with HTML form elements.</a></li>
</ol>

<h2>Documentation</h2>


<h3>Basic complete example</h3>

<pre>
var data = {list:[1, 2, 3]};
var template = likely.Template([
'for key, value in list',
' p',
'  {{ value }}'
]);
var div = document.getElementById('c1');
var binding = new likely.Binding(div, template, data);
</pre>

<p>Produce</p>

<pre>&lt;p&gt;1&lt;/p&gt;&lt;p&gt;2&lt;/p&gt;&lt;p&gt;3&lt;/p&gt;</pre>

<h3>Generating HTML</h3>

<p>Any line starting by an alphabetical letter which is not part of the reserved words will produce an HTML node. Indentation indicates the nesting of the nodes. Only one node by line is allowed.</p>

<pre>ul
  li
    a href="/"
      "Home"
</pre>

<p>Will produce</p>

<pre>&lt;ul&gt;&lt;li&gt;&lt;a href="/"&gt;Home&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</pre>

<h3>Bidirectional Data Binding</h3>

<p>Likely.js regonize elements with a value attribute (input, textarea and select) and will produce specific HTML
that enable to easily update the data object. The condition for
the data binding to trigger is to have only have one single expression mapped to the value attribute.</p>

<pre>
var tpl = likely.Template("input value={{ name }}");
var div = document.getElementById('c1');
var data = {name:"Chevalier d'Eon"};
var binding = new likely.Binding(div, tpl, data);
</pre>

<p>Produce</p>

<pre>&lt;input value="Chevalier d'Eon" lk-bind=".name"&gt;</pre>

<p>The binding takes care of the events and to reflect back the changes to the data object.
You have (for now) to notify the binding by hand when the data has changed by calling:</p>

<pre>binding.update();</pre>

<h4>Manual Data Binding</h4>

<p>When the value of an HTML element has to be binded to another target you
can defined the lk-bind attribute yourself. E.g.</p>

<pre>for n in numbers
  input type="radio" value="{{ n }}" lk-bind=".selected"</pre>


<p>There is a <a href="forms.html">demo of bidirectional data binding with HTML form elements.</a></p>

<h3>Flow Control</h3>

<h4>For Loop</h4>

<p>Iterate over an object or array. Syntax: </p>
<pre><strong>for</strong> [key,] value <strong>in</strong> iterable
  "{{ key }} : {{ value }}"
</pre>

<h4>If / Elseif / Else</h4>

<p>Conditions. Syntax: </p>
<pre><strong>if</strong> expression
  "something"
<strong>elseif</strong> expression
  "something else"
<strong>else</strong>
  "otherwise"
</pre>

<h4>Include</h4>

<pre>
likely.Template('"hello {{ value }}"', "template1");
var tpl = likely.Template("<strong>include</strong> template1");
var binding = new likely.Binding(div, tpl, {value:"world"});
</pre>

<p>Produce</p>

<pre>hello world</pre>

<h3>Strings</h4>

<p>To declare a string you need to start and end a line with a double quote.</p>

<pre>
p
  "my paragraph text"
</pre>

<h4>Multi Line Strings</h4>

<p>By using 3 double quotes strings can span across multiple lines</p>

<pre>
p
  """my long
     paragraph of text"""
</pre>

<h4>Comments</h4>

<p>A line starting by a # will be ignored.</p>

<pre>p
  # some math
  {{ 1 + 2 }}
 </pre>

 <h4>Empty lines</h4>

 <p>Empty lines are significant and produce a carriage return inside the rendered HTML.

<pre>p

p</pre>

<p>Produce</p>

<pre>&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;</pre>

<h3>Expressions</h3>

<p>Expressions can be used in if/else nodes, HTML attributes, inside strings, or simply as
standalone nodes.</p>

<pre>
h1
  "Expression as node "
  <strong>{{ value }}</strong>
if <strong>value > 10</strong>
  "<strong>{{ value }}</strong> is bigger than 10"
else
  "Please enter a value bigger than 10"
  input value="<strong>{{ value }}</strong>"</pre>
</pre>

<h4>Math</h4>

<pre>p
  {{ 1 + 2 * 2 - 1 }}</pre>

<p>Produce</p>

<pre>&lt;p&gt;4&lt;/p&gt;</pre>

<h4>In operator</h4>

<pre>{{ "a" <strong>in</strong> "hallo" }}</pre>

<p>Produce</p>

<pre>true</pre>

<h4>If operator</h4>

<pre>p class="{{ 'selected' <strong>if</strong> key == selected }}"</pre>

<p>Produce</p>

<pre>&lt;p class="selected"&gt;&lt;/p&gt;</pre>

<h4>Filter Operator</h4>

<p>The filter operator pass the left value to a function available in the 
current Context.

<pre>var data = {classname: "Selected", lowercase: 
  function(value, context){
    return v.toLowerCase();
  }
};
var tpl = likely.Template('p class="{{ classname <strong>|</strong> lowercase }}"');
var binding = new likely.Binding(div, tpl, data);</pre>

<pre>&lt;p class="selected"&gt;&lt;/p&gt;</pre>

<p>Produce</p>

<h3>Function Call and Events</h3>

<p>Given a function in your data</p>

<pre>var data = {
  lastCalled:null,
  <strong>callMe</strong>:function(param){
    data.lastCalled = param;
    return "called";
  }
};</pre>

<p>This function <strong>callMe</strong> can be called anywhere in your template. A function call is just another expression so it will be evaluated once at the template evalutation time.</p>

<pre>p class={{ <strong>callMe</strong>("get a class") }}')
  "class get the value 'called'"</pre>

<p>In the other hand if the function is called within an event attribute, the evaluation is executed only
at runtime, when the event is triggered.</p>

<pre>p lk-click={{ <strong>callMe</strong>("p clicked") }}
  "Only when clicked"</pre>

<p>For a more complex example <a href="crud.html">checkout the basic CRUD application demo.</a></p>

<h3>Components</h3>

<p>A component is a piece of reusable template that can be referenced by name within the language. A component can also define a controller function that can manipulate the context before rendering.</a>

<pre>
var tpl2 = likely.Template([
  "li",
  "  {{ value }}"
]);

var c = likely.Component("HelloListItem", tpl2, function(context){
  context.set("value", "Hello " + context.get("value"));
});
</pre>

<p>Once this component declared you can use it in your template by calling.</p>

<pre>
ul
  for value in list
    component HelloListItem
</pre>

</div>
</div>

<script src="dist/likely.js"></script>
<script src="lib/jsonfn.js"></script>


<script>

function get(id) { return document.getElementById(id); }

var r = get("result");
var rh = get("resulth");
var tpl = get("template");
var d = get("data");
var errors = get("errors");
var t, render;

var data = JSONfn.parse(d.value);
var currentTemplate = likely.Template(tpl.value);

var binding = new likely.Binding(rh, currentTemplate, data);
r.innerHTML = likely.escape(rh.innerHTML);

rh.addEventListener("dataViewChanged", function() {
  d.value = JSON.stringify(data, null, 2);
  r.innerHTML = likely.escape(rh.innerHTML);
});

var tpl2 = likely.Template([
  "li", 
  "  {{ value }}"
]);

var c = likely.Component("HelloListItem", tpl2, function(context){
  context.set("value", "Hello " + context.get("value"));
});

tpl.onkeyup = logErrors(function(){
  binding.template = likely.Template(tpl.value);
  binding.update();
  r.innerHTML = likely.escape(rh.innerHTML);
});
d.onkeyup = logErrors(function(){
  data = JSONfn.parse(d.value);
  binding.data = data;
  binding.update();
  r.innerHTML = likely.escape(rh.innerHTML);
});

function logErrors(fct) {
  return function() {
    errors.style.display = 'none';
    try {
      return fct();
    } catch(e) {
      errors.innerHTML = e.toString();
      errors.style.display = 'block';
      throw e;
    }
  };
}



</script>
